import React from "react";
export declare type IntrinsicElementsKeys = keyof JSX.IntrinsicElements;
export declare const mergeArrays: (template: TemplateStringsArray, templateElements: (string | undefined | null)[]) => (string | null | undefined)[];
export declare const cleanTemplate: (template: (string | undefined | null)[], inheritedClasses?: string) => string;
declare type TransientProps = Record<`$${string}`, any>;
declare type NoInfer<T> = [T][T extends any ? 0 : never];
declare type StripCallSignature<T> = {
    [K in keyof T]: T[K];
};
export interface TailwindComponent<P extends {}> extends StripCallSignature<React.ForwardRefExoticComponent<P>> {
    (props: P & {
        $as?: never | undefined;
    }): React.ReactElement<any> | null;
    <As extends IntrinsicElementsKeys>(props: P & {
        $as?: As;
    } & JSX.IntrinsicElements[As]): React.ReactElement<any> | null;
    <P2 extends {}>(props: P & {
        $as?: React.ComponentType<P2>;
    } & NoInfer<P2>): React.ReactElement<any> | null;
}
export declare type TemplateFunction<P, E> = <K extends TransientProps = {}>(template: TemplateStringsArray, ...templateElements: ((props: P & K) => string | undefined | null)[]) => TailwindComponent<React.PropsWithoutRef<P & K> & React.RefAttributes<E>>;
interface ClassNameProp {
    className?: string;
}
interface AsProp {
    $as?: keyof JSX.IntrinsicElements | React.ComponentType<any>;
}
declare function templateFunction<P extends ClassNameProp & AsProp, E = any>(Element: React.ComponentType<P>): TemplateFunction<P, E>;
export declare type IntrinsicElements = {
    [key in keyof JSX.IntrinsicElements]: TemplateFunction<JSX.IntrinsicElements[key], React.ElementRef<key> | undefined>;
};
declare const tw: typeof templateFunction & IntrinsicElements;
export default tw;
