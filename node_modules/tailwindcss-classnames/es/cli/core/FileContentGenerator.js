import _ from 'lodash';
var FileContentGenerator = /** @class */ (function () {
    /**
     * Initializes a new instance of the `FileContentGenerator` class.
     * @param generatedClassnames The generated classnames to put in the template.
     */
    function FileContentGenerator(generatedClassnames, configParser) {
        var _this = this;
        this.generateFileContent = function () {
            return (_this.fileHeaderTemplate() +
                '\n\n' +
                _this.importStatementsTemplate() +
                '\n\n' +
                _this.regularClassnamesTypesTemplate() +
                '\n\n' +
                _this.variantsTypeTemplate() +
                '\n\n' +
                _this.utilityFunctionsTemplate() +
                '\n\n' +
                _this.mainExportStatementsTemplate());
        };
        this.fileHeaderTemplate = function () {
            return ('/* eslint-disable */\n' +
                '/* tslint:disable */\n' +
                '\n' +
                '//////////////////////////////////////////////////////////////////////////////\n' +
                '/// Autogenerated by tailwindcss-classnames CLI. https://git.io/JtsPU\n' +
                '/// DO NOT EDIT THIS FILE DIRECTLY!\n' +
                '//////////////////////////////////////////////////////////////////////////////\n');
        };
        this.importStatementsTemplate = function () {
            return "import classnamesLib from 'clsx';" + '\n' + "T_CUSTOM_CLASSES_IMPORT_STATEMENT";
        };
        this.variantsTypeTemplate = function () {
            var variants = _this._configParser.getVariants();
            return _this.generateTypesTemplate('PseudoClassVariants', variants.map(function (variant) { return variant + _this._configParser.getSeparator(); }), // 'hover:', 'focus:'
            undefined, true);
        };
        this.regularClassnamesTypesTemplate = function () {
            return Object.keys(_this._generatedClassNames)
                .map(function (classGroupKey) {
                return _this.generateTypesGroupTemplate(_this._generatedClassNames[classGroupKey], classGroupKey);
            })
                .join('\n');
        };
        this.utilityFunctionsTemplate = function () {
            var template = '//////////// Utility Function generic type\n\n' +
                'type TUtilityFunction<T extends string> = (\n' +
                '  ...args: Array<\n' +
                '    | T\n' +
                '    | `!${T}`\n' +
                '    | `${TPseudoClassVariants}${T}`\n' +
                '    | `${TPseudoClassVariants}!${T}`\n' +
                '    | null\n' +
                '    | undefined\n' +
                '    | {[key in T | `${TPseudoClassVariants}${T}` | `!${T}` | `${TPseudoClassVariants}!${T}` | TTailwindString]?: boolean}\n' +
                '    | TTailwindString\n' +
                '  >\n' +
                ') => TTailwindString;';
            for (var _i = 0, _a = Object.entries(_this._generatedClassNames); _i < _a.length; _i++) {
                var _b = _a[_i], categoryKey = _b[0], value = _b[1];
                var subCategoriesTemplate = Object.keys(value) // sub-ctegories keys
                    .map(function (SubCategory) {
                    var fnName = _.camelCase(SubCategory);
                    var fnType = "TUtilityFunction<T" + _.upperFirst(SubCategory) + ">";
                    return "export const " + fnName + ": " + fnType + " = classnamesLib as any";
                })
                    .join('\n');
                template =
                    template +
                        '\n' +
                        ("\n//////////// " + categoryKey + " Utility functions\n") +
                        '\n' +
                        subCategoriesTemplate;
            }
            return template;
        };
        this.mainExportStatementsTemplate = function () {
            var utilityFunctionsObjectTemplate = Object.keys(_this._generatedClassNames)
                .map(function (cn) {
                var subCategoryObj = _this._generatedClassNames[cn];
                if (subCategoryObj !== undefined) {
                    return Object.keys(subCategoryObj)
                        .map(function (sc) { return '  ' + sc; })
                        .join(',\n');
                }
            })
                .join(',\n');
            return ("export const TW = {\n" + utilityFunctionsObjectTemplate + "\n}\n" +
                '\n' +
                'export type TTailwindString = "TAILWIND_STRING"\n' +
                '\n' +
                'export type TArg =\n' +
                '| null\n' +
                '| undefined\n' +
                '| TTailwindString\nIMPORTED_T_CUSTOM_CLASSES_ARG' +
                '\n' +
                'export type TTailwind = (...args: TArg[]) => TTailwindString\n' +
                '\n' +
                'export const classnames: TTailwind = classnamesLib as any\n' +
                '\n' +
                'export default classnames');
        };
        /**
         * Generates types group template for a utility classes group object.
         *
         *
         * ### example:
         *
         * A utility group object as:
         *
         * ```js
         * const FlexBox = {
         *   alignSelf: ['self-auto', 'self-start', 'self-center'],
         *   flexWrap: ['flex-nowrap', 'flex-wrap'],
         * }
         *```
         *
         * will produce a template which looks like this:
         *
         * ```ts
         * export type TFlexWrap =
         * | 'flex-nowrap'
         * | 'flex-wrap';
         *
         * export type TAlignSelf =
         * | 'self-auto'
         * | 'self-start'
         * | 'self-center';
         *
         * export type TFlexBox = TFlexWrap | TAlignSelf;
         * ```
         */
        this.generateTypesGroupTemplate = function (group, groupName) {
            var members = Object.keys(group);
            var generateMembersStatements = function () {
                return members.map(function (member) {
                    return _this.generateTypesTemplate(member, group[member], _this._configParser.getPrefix());
                });
            };
            var generateGroupStatement = function () {
                var getMembersStatementsReferences = function () {
                    return members.map(function (member) { return 'T' + _.upperFirst(member); }).join('\n  | ');
                };
                return ("export type T" + _.upperFirst(groupName) + " =" +
                    '\n  | ' +
                    getMembersStatementsReferences() +
                    '\n');
            };
            return generateMembersStatements().join('\n\n') + '\n\n' + generateGroupStatement();
        };
        /**
         * Generates TS types template from a list of strings.
         *
         * #### Example:
         *
         * Given typeName: 'baz' and items:
         * ```js
         * ['foo', 'bar']
         * ```
         *
         * generates:
         *
         * ```
         * export type TBaz
         *   | foo
         *   | bar;
         * ```
         * or with quoutes:
         * ```
         * export type TBaz
         *   | 'foo'
         *   | 'bar';
         * ```
         * @param typeName The name of the type (without T prefix).
         * @param items The list of the strings of items to add to the type name.
         * @param prefix The prefix to add to the beginning of each item of the string array.
         * @param surroundWithQuotes Whether to quote the types or not (make it a string or an actual type)
         */
        this.generateTypesTemplate = function (typeName, items, prefix, surroundWithQuotes) {
            if (surroundWithQuotes === void 0) { surroundWithQuotes = true; }
            return ("export type T" + _.upperFirst(typeName) + " =" +
                '\n  | ' +
                items
                    .flatMap(function (item) {
                    var classnamesThatShouldKeepTheDefaultSuffix = ['cursor'];
                    return classnamesThatShouldKeepTheDefaultSuffix.map(function (x) {
                        var shouldKeepDefaultSuffix = item.includes(x);
                        var name = shouldKeepDefaultSuffix ? item : item.replace('-DEFAULT', '');
                        var nameWithOrWithoutPrefix = "" + (prefix ? prefix : '') + name;
                        return surroundWithQuotes ? "'" + nameWithOrWithoutPrefix + "'" : nameWithOrWithoutPrefix;
                    });
                })
                    .join('\n  | '));
        };
        this._configParser = configParser;
        this._generatedClassNames = generatedClassnames;
    }
    return FileContentGenerator;
}());
export { FileContentGenerator };
//# sourceMappingURL=FileContentGenerator.js.map